#include <iostream>

using namespace std;

int main(void)
{
    // 1. 자동(auto) 변수 : 선언된 함수 내부나 블록 안에서만 유효하고, 벗어나면 자동적으로 소멸된다.
    auto int x1, x2; // int x1, x2;

    // 2. 정적(static) 변수 : 프로그램의 실행이 종료한 후에도 값이 소멸되지 않고, 메모리에 기억되는 변수다.
    static int x3, x4;

    // 3. 레지스터(register) 변수 : 고속의 임시 기억 장소인 레지스터를 활용해 실행 속도를 높이는 효과를 가져오는 변수다.
    register int x5, x6;

    // 4. 외부(extern) 변수 : 프로그램 전체에 유효한 범위를 가지거나 다른 프로그램에 있는 함수에 영향을 끼치는 변수다.
    extern int x7, x8;

    int a[][COL] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    int *p;
    
    p = a; // a는 int (*)[4] 타입
    p = a[0]; // a[0]은 int * 타입
    p = a[0][0]; // a[0][0]은 int 타입
    p = &a[0][0]; // &a[0][0]은 int * 타입

    return 0;
}

/* 접근 제어자(Access Modifier) */
// 1. private (전용)
// class의 기본 접근제어자인 private는 객체의 멤버를 외부에 공개하지 않고 직접적인 접근 또한 불가능하게 한다.
// 오직 동일 클래스 내에 있는 멤버 또는 friend 함수만 접근 가능하기 때문에 필요시 public으로 선언된 메소드를 이용하여 기능을 수행한다.

// 2. public (공용)
// public 접근제어자로 설정된 멤버 변수 및 멤버 함수는 외부에 공개되어 아무 제약 없이 접근 가능하며 해당 객체를 사용하는 곳이면 어디서든 접근 가능하다.
// class는 기본적으로 private지만 public 접근제어자를 사용하여 외부에서 접근 가능하도록 선언할 수 있다.

// 3. protected (보호)
// private로 정보 은닉을 수행하고 public을 통해 필요시에 private에 접근을 가능하게 했다.
// 이 두 가지 만으로도 정보은닉에 대한 수행은 모두 가능한 것처럼 보이나 protected란 제어자가 하나 더 존재한다.

// 그 이유는 뒤에 정리할 클래스의 상속에 관한 제어 자이다.
// private로 선언할 경우 해당 클래스에서만 접근 가능하기 때문에 해당 클래스를 상속받은 하위 클래스라 할지라도 접근이 불가능하다.
// 따라서 private의 기능을 수행하면서 상속한 하위 클래스에 대해서는 접근을 가능하도록 해주는 제어자이다.
// 즉, 상속된 하위 클래스에 대해서는 public의 역할을 수행하나 그 외 외부 접근은 모두 private의 역할을 수행하도록 하는 제어 자이다.

// protected에 접근 가능한 객체는 다음과 같다.
// 1) 동일 객체 내의 멤버
// 2) 해당 클래스의 friend
// 3) 해당 객체를 public 또는 protected로 파생된 클래스